[1mdiff --git a/src/robo_pointer_visual/robo_pointer_visual/real_robot_interface.py b/src/robo_pointer_visual/robo_pointer_visual/real_robot_interface.py[m
[1mindex 34b57b6..555a6d1 100644[m
[1m--- a/src/robo_pointer_visual/robo_pointer_visual/real_robot_interface.py[m
[1m+++ b/src/robo_pointer_visual/robo_pointer_visual/real_robot_interface.py[m
[36m@@ -1,5 +1,5 @@[m
 # Fichier: ~/ros2_ws/src/robo_pointer_visual/robo_pointer_visual/real_robot_interface.py[m
[31m-# Version: ID2_ANGULAR_COMPENSATION_V1[m
[32m+[m[32m# Version: Finalized_V1_With_Full_JointState_Offsets[m
 [m
 import numpy as np[m
 import math[m
[36m@@ -10,17 +10,18 @@[m [mimport enum[m
 import rclpy[m
 from rclpy.node import Node[m
 from geometry_msgs.msg import Vector3[m
[31m-import traceback[m
[32m+[m[32mfrom sensor_msgs.msg import JointState[m
[32m+[m[32mimport traceback[m[41m [m
 from ament_index_python.packages import get_package_share_directory[m
 [m
[31m-# Utilisation directe de FeetechMotorsBus (pour config et connexion bas niveau)[m
[32m+[m[32m# Utilisation directe de FeetechMotorsBus[m
 from lerobot.common.robot_devices.motors.feetech import FeetechMotorsBus, FeetechMotorsBusConfig[m
 # Importation directe du SDK bas niveau[m
 try:[m
     import scservo_sdk as scs[m
[31m-    from scservo_sdk import GroupSyncRead[m
[31m-    from scservo_sdk import GroupSyncWrite[m
[32m+[m[32m    from scservo_sdk import GroupSyncRead, GroupSyncWrite[m
 except ImportError:[m
[32m+[m[32m    # This is a critical error, log and allow __init__ to raise it[m
     print("ERREUR CRITIQUE: Le paquet scservo_sdk n'est pas install√© ou incomplet.")[m
     print("Veuillez l'installer via 'pip install -e \".[feetech]\"' dans le dossier lerobot.")[m
     scs = None[m
[36m@@ -35,7 +36,7 @@[m [mNODE_NAME = 'real_robot_interface'[m
 PACKAGE_NAME = 'robo_pointer_visual'[m
 DEFAULT_CALIBRATION_FILENAME = 'manual_calibration_follower.json'[m
 [m
[31m-LEADER_ARM_PORT = "/dev/ttyACM0"[m
[32m+[m[32mLEADER_ARM_PORT = "/dev/ttyACM0" # Default port, consider making it a ROS parameter[m
 LEADER_ARM_MOTORS = {[m
     "shoulder_pan": [1, "sts3215"],[m
     "shoulder_lift": [2, "sts3215"],[m
[36m@@ -44,74 +45,74 @@[m [mLEADER_ARM_MOTORS = {[m
     "wrist_roll": [5, "sts3215"],[m
     "gripper": [6, "sts3215"],[m
 }[m
[32m+[m[32m# Order for calibration file and internal consistency[m
 MOTOR_NAMES_ORDER = list(LEADER_ARM_MOTORS.keys())[m
[31m-MODEL_RESOLUTION = {"sts3215": 4096}[m
[32m+[m[32mMODEL_RESOLUTION = {"sts3215": 4096} # Steps per full revolution for sts3215[m
 HALF_TURN_DEGREE = 180.0[m
[32m+[m
[32m+[m[32m# Feetech Servo Control Table Addresses and Lengths[m
 SCS_CONTROL_TABLE = {[m
     "Torque_Enable": (40, 1),[m
     "Goal_Position": (42, 2),[m
     "Present_Position": (56, 2),[m
[31m-    "Status_Return_Level": (16, 1),[m
[32m+[m[32m    "Status_Return_Level": (16, 1), # To disable reply packets[m
 }[m
[32m+[m
[32m+[m[32m# Motors actively controlled by the IK/PI logic[m
 MOTORS_TO_COMMAND = ["shoulder_pan", "shoulder_lift", "elbow_flex"][m
[32m+[m[32m# Initial pose for the controlled motors when holding[m
 INITIAL_HOLD_POSE_DEG = np.array([0.0, 90.0, 90.0], dtype=np.float32)[m
[32m+[m[32m# Initial position for wrist_flex if set independently at startup[m
 INITIAL_WRIST_POS_DEG = 0.0[m
 [m
 class CalibrationMode(enum.Enum):[m
     DEGREE = 0[m
     LINEAR = 1[m
 [m
[31m-# --- Fonctions de Calibration ---[m
[32m+[m[32m# --- Fonctions de Calibration (Identiques √† la version pr√©c√©dente) ---[m
 def apply_calibration(raw_values: np.ndarray, motor_names: list[str], calibration_data: dict, motors_def: dict):[m
[31m-    """[m
[31m-    Convertit les steps bruts lus des moteurs (int32) en valeurs calibr√©es [m
[31m-    (degr√©s pour les joints rotatifs, pourcentage pour les lin√©aires) en float32.[m
[31m-    G√®re le wrap-around pour les moteurs rotatifs.[m
[31m-    """[m
     if calibration_data is None:[m
[31m-        print("[ERROR] apply_calibration: calibration_data is None!")[m
[32m+[m[32m        # Logged by caller if necessary[m
         return np.full(len(motor_names), np.nan, dtype=np.float32)[m
 [m
     calibrated_values = np.full(len(motor_names), np.nan, dtype=np.float32)[m
 [m
     for i, name in enumerate(motor_names):[m
         if name not in calibration_data["motor_names"]:[m
[31m-            continue # Motor not in calibration file, skip[m
[32m+[m[32m            continue[m
 [m
         try:[m
             calib_idx = calibration_data["motor_names"].index(name)[m
[31m-            # Basic checks for data integrity[m
             if not (calib_idx < len(calibration_data.get("drive_mode", [])) and \[m
                     calib_idx < len(calibration_data.get("homing_offset", [])) and \[m
                     calib_idx < len(calibration_data.get("calib_mode", []))):[m
[31m-                print(f"[ERROR apply_calib] Calibration data lists mismatch for motor '{name}'.")[m
[32m+[m[32m                # This indicates a malformed calibration file, error should be logged by caller[m
                 continue[m
 [m
             calib_mode_str = calibration_data["calib_mode"][calib_idx][m
[31m-            try: calib_mode = CalibrationMode[calib_mode_str][m
[32m+[m[32m            try: calib_mode = CalibrationMode[calib_mode_str.upper()] # Ensure uppercase for enum matching[m
             except KeyError:[m
[31m-                print(f"[ERROR apply_calib] Invalid calib_mode '{calib_mode_str}' for motor '{name}'.")[m
[31m-                continue[m
[32m+[m[32m                continue # Invalid calib_mode string[m
 [m
             drive_mode = calibration_data["drive_mode"][calib_idx][m
             homing_offset = float(calibration_data["homing_offset"][calib_idx])[m
[31m-            _, model = motors_def[name][m
[32m+[m[32m            _, model = motors_def[name] # Assumes motors_def has all names in motor_names[m
             resolution = float(MODEL_RESOLUTION[model])[m
             current_raw_value = float(raw_values[i])[m
             steps_per_180_deg = resolution / 2.0[m
 [m
             if calib_mode == CalibrationMode.DEGREE:[m
[31m-                if abs(steps_per_180_deg) < 1e-9: continue # Invalid resolution[m
[32m+[m[32m                if abs(steps_per_180_deg) < 1e-9: continue # Avoid division by zero[m
 [m
[31m-                raw_zero = -homing_offset # Homing offset is defined relative to the "zero step"[m
[32m+[m[32m                raw_zero = -homing_offset[m
                 delta_raw = current_raw_value - raw_zero[m
[31m-                # Handle wrap-around: if delta is > half turn, assume it wrapped[m
[32m+[m[41m                [m
                 delta_normalized = delta_raw[m
                 if delta_raw > steps_per_180_deg: delta_normalized = delta_raw - resolution[m
                 elif delta_raw < -steps_per_180_deg: delta_normalized = delta_raw + resolution[m
                 [m
                 delta_steps_calibrated = delta_normalized[m
[31m-                if drive_mode == 1: delta_steps_calibrated *= -1.0 # Invert if drive mode is 1[m
[32m+[m[32m                if drive_mode == 1: delta_steps_calibrated *= -1.0[m
 [m
                 calibrated_degrees = delta_steps_calibrated / steps_per_180_deg * HALF_TURN_DEGREE[m
                 calibrated_values[i] = calibrated_degrees[m
[36m@@ -119,33 +120,28 @@[m [mdef apply_calibration(raw_values: np.ndarray, motor_names: list[str], calibratio[m
             elif calib_mode == CalibrationMode.LINEAR:[m
                  if not (calib_idx < len(calibration_data.get("start_pos", [])) and \[m
                          calib_idx < len(calibration_data.get("end_pos", []))):[m
[31m-                      continue # Missing start/end_pos for linear motor[m
[32m+[m[32m                      continue[m
                  start_pos = float(calibration_data["start_pos"][calib_idx])[m
                  end_pos = float(calibration_data["end_pos"][calib_idx])[m
[31m-                 if abs(end_pos - start_pos) < 1e-6: # Avoid division by zero[m
[32m+[m[32m                 if abs(end_pos - start_pos) < 1e-6:[m
                       calibrated_values[i] = 0.0 if current_raw_value == start_pos else 50.0[m
                  else:[m
                       percentage = (current_raw_value - start_pos) / (end_pos - start_pos) * 100.0[m
[31m-                      calibrated_values[i] = np.clip(percentage, -10.0, 110.0) # Allow slight over/undershoot[m
[31m-        except Exception as e:[m
[31m-            print(f"[ERROR apply_calib] Unexpected error processing motor '{name}': {e}")[m
[31m-            traceback.print_exc()[m
[32m+[m[32m                      calibrated_values[i] = np.clip(percentage, -10.0, 110.0)[m
[32m+[m[32m        except Exception:[m
[32m+[m[32m            # Error during processing a specific motor, log handled by caller if needed[m
[32m+[m[32m            # traceback.print_exc() # Uncomment for deep debugging if errors persist here[m
[32m+[m[32m            pass # Continue to next motor[m
     return calibrated_values[m
 [m
 def revert_calibration(target_values_calibrated: np.ndarray, motor_names: list[str], calibration_data: dict, motors_def: dict):[m
[31m-    """[m
[31m-    Convertit les valeurs cibles calibr√©es (degr√©s/pourcentage) en steps bruts (int32) pour l'envoi aux moteurs.[m
[31m-    Les steps finaux sont clipp√©s aux limites start_pos/end_pos d√©finies dans le fichier JSON de calibration,[m
[31m-    puis aux limites absolues du moteur (0 √† r√©solution-1).[m
[31m-    """[m
     if calibration_data is None:[m
[31m-         print("[ERROR revert_calib] calibration_data is None!")[m
[31m-         return None[m
[32m+[m[32m         return None # Logged by caller[m
 [m
     target_steps = np.zeros(len(motor_names), dtype=np.int32)[m
 [m
     for i, name in enumerate(motor_names):[m
[31m-        motor_model_tuple = motors_def.get(name, ["", "sts3215"]) # Default to sts3215 if name not found[m
[32m+[m[32m        motor_model_tuple = motors_def.get(name, ["", "sts3215"])[m
         default_step = MODEL_RESOLUTION.get(motor_model_tuple[1], 4096) // 2[m
 [m
         if name not in calibration_data["motor_names"]:[m
[36m@@ -157,18 +153,15 @@[m [mdef revert_calibration(target_values_calibrated: np.ndarray, motor_names: list[s[m
             if not (calib_idx < len(calibration_data.get("drive_mode", [])) and \[m
                     calib_idx < len(calibration_data.get("homing_offset", [])) and \[m
                     calib_idx < len(calibration_data.get("calib_mode", []))):[m
[31m-                print(f"[ERROR revert_calib] Calibration data lists mismatch for motor '{name}'.")[m
                 target_steps[i] = default_step[m
                 continue[m
 [m
             calib_mode_str = calibration_data["calib_mode"][calib_idx][m
[31m-            try: calib_mode = CalibrationMode[calib_mode_str][m
[32m+[m[32m            try: calib_mode = CalibrationMode[calib_mode_str.upper()][m
             except KeyError:[m
[31m-                print(f"[ERROR revert_calib] Invalid calib_mode '{calib_mode_str}' for motor '{name}'.")[m
                 target_steps[i] = default_step[m
                 continue[m
 [m
[31m-            # Determine hardware step limits from JSON if available[m
             apply_hw_clip_from_json = False[m
             hw_min_step_json = 0.0[m
             hw_max_step_json = float(MODEL_RESOLUTION.get(motor_model_tuple[1], 4096) -1)[m
[36m@@ -185,16 +178,16 @@[m [mdef revert_calibration(target_values_calibrated: np.ndarray, motor_names: list[s[m
             _, model = motor_model_tuple[m
             resolution = float(MODEL_RESOLUTION[model])[m
             current_target_calibrated = float(target_values_calibrated[i])[m
[31m-            target_step_raw = float(default_step) # Fallback[m
[32m+[m[32m            target_step_raw = float(default_step)[m
 [m
             if calib_mode == CalibrationMode.DEGREE:[m
                 steps_per_180_deg = resolution / 2.0[m
                 if abs(steps_per_180_deg) < 1e-9: continue[m
                 step_centered = current_target_calibrated / HALF_TURN_DEGREE * steps_per_180_deg[m
                 if drive_mode == 1: step_centered *= -1.0[m
[31m-                target_step_raw = step_centered - homing_offset # homing_offset is defined as "value to subtract"[m
[32m+[m[32m                target_step_raw = step_centered - homing_offset[m
             elif calib_mode == CalibrationMode.LINEAR:[m
[31m-                 if not apply_hw_clip_from_json: # Linear mode requires start/end pos from JSON[m
[32m+[m[32m                 if not apply_hw_clip_from_json:[m
                       target_steps[i] = default_step[m
                       continue[m
                  start_pos_json = hw_min_step_json[m
[36m@@ -205,31 +198,32 @@[m [mdef revert_calibration(target_values_calibrated: np.ndarray, motor_names: list[s[m
                      target_percentage_clipped = np.clip(current_target_calibrated, 0.0, 100.0)[m
                      target_step_raw = (target_percentage_clipped / 100.0) * (end_pos_json - start_pos_json) + start_pos_json[m
 [m
[31m-            # Apply clipping: first to JSON limits (if any), then to motor's absolute limits[m
             final_step_value_clipped_json = target_step_raw[m
             if apply_hw_clip_from_json:[m
                 final_step_value_clipped_json = np.clip(target_step_raw, hw_min_step_json, hw_max_step_json)[m
             [m
[31m-            # Final clip to absolute motor range [0, resolution-1][m
             final_step_value_abs_clipped = int(round(np.clip(final_step_value_clipped_json, 0, resolution - 1)))[m
             target_steps[i] = final_step_value_abs_clipped[m
 [m
[31m-        except Exception as e:[m
[31m-            print(f"[ERROR revert_calib] Unexpected error processing motor '{name}': {e}")[m
[31m-            traceback.print_exc()[m
[32m+[m[32m        except Exception:[m
[32m+[m[32m            # traceback.print_exc() # Uncomment for deep debugging[m
             target_steps[i] = default_step[m
     return target_steps[m
 [m
[32m+[m
 class RealRobotInterfaceNode(Node):[m
     """[m
     ROS 2 Node to interface with the real robot arm (SO-100 or similar Feetech-based).[m
     It subscribes to control signals, reads motor states, calculates target motor commands[m
     using Inverse Kinematics (IK) and Proportional-Integral (PI) control,[m
[31m-    and sends these commands to the motors.[m
[32m+[m[32m    and sends these commands to the motors. It also publishes the robot's[m
[32m+[m[32m    joint states for visualization in RViz.[m
     """[m
     def __init__(self):[m
         super().__init__(NODE_NAME)[m
[31m-        self.get_logger().info(f"{NODE_NAME} node starting... (ID2_ANGULAR_COMPENSATION_V1 Version)")[m
[32m+[m[32m        self.get_logger().info(f"{NODE_NAME} node starting... (Version: Finalized_V1_With_Full_JointState_Offsets)")[m
[32m+[m[41m        [m
[32m+[m[32m        # Initialize all instance attributes to ensure they exist[m
         self.leader_bus_instance = None[m
         self.port_handler = None[m
         self.packet_handler = None[m
[36m@@ -237,204 +231,225 @@[m [mclass RealRobotInterfaceNode(Node):[m
         self.group_writer = None[m
         self.group_reader = None[m
         self.control_signal_subscription = None[m
[32m+[m[32m        self.joint_state_publisher = None[m
         self.reader_motors_ok = False[m
         self.last_valid_target_angles = None[m
         self.last_sent_target_steps = None[m
         self.last_known_raw_positions = None[m
         self.last_read_time = self.get_clock().now()[m
 [m
[32m+[m[32m        # URDF joint names in the order they appear in the URDF file for JointState messages[m
[32m+[m[32m        self.joint_names_urdf_order = ['Rotation', 'Pitch', 'Elbow', 'Wrist_Pitch', 'Wrist_Roll', 'Jaw'][m
[32m+[m[41m        [m
[32m+[m[32m        # Mapping from internal motor names to URDF joint names[m
[32m+[m[32m        self.active_motor_names_map = {[m
[32m+[m[32m            "shoulder_pan": "Rotation",[m
[32m+[m[32m            "shoulder_lift": "Pitch",[m
[32m+[m[32m            "elbow_flex": "Elbow",[m
[32m+[m[32m            "wrist_flex": "Wrist_Pitch",[m
[32m+[m[32m            "wrist_roll": "Wrist_Roll",[m
[32m+[m[32m            "gripper": "Jaw"[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        # Offsets to align physical robot zero with URDF zero (in radians)[m
[32m+[m[32m        self.joint_offsets_rad = {[m
[32m+[m[32m            'Rotation': 0.0000,    # shoulder_pan (ID1)[m
[32m+[m[32m            'Pitch': -1.6889,      # shoulder_lift (ID2)[m
[32m+[m[32m            'Elbow': -1.5186,      # elbow_flex (ID3)[m
[32m+[m[32m            'Wrist_Pitch': -1.5156,# wrist_flex (ID4)[m
[32m+[m[32m            'Wrist_Roll': 0.0,     # wrist_roll (ID5) - Calibrate if needed[m
[32m+[m[32m            'Jaw': 0.0             # gripper (ID6) - Calibrate if needed[m
[32m+[m[32m        }[m
[32m+[m
         if scs is None or GroupSyncRead is None or GroupSyncWrite is None:[m
[31m-             self.get_logger().fatal("scservo_sdk or required Group classes not found. Aborting.")[m
[32m+[m[32m             self.get_logger().fatal("scservo_sdk or required Group classes not found. Aborting initialization.")[m
              raise ImportError("scservo_sdk is required but not installed or incomplete.")[m
 [m
         try:[m
[31m-            # 1. Load Manual Calibration File[m
[31m-            try:[m
[31m-                package_share_directory = get_package_share_directory(PACKAGE_NAME)[m
[31m-                calibration_file_path = Path(package_share_directory) / 'config' / DEFAULT_CALIBRATION_FILENAME[m
[31m-            except Exception as e:[m
[31m-                self.get_logger().fatal(f"Could not find package share directory '{PACKAGE_NAME}' or construct path: {e}")[m
[31m-                raise RuntimeError("Failed to get calibration file path") from e[m
[31m-            [m
[31m-            if not calibration_file_path.exists():[m
[31m-                self.get_logger().error(f"MANUAL Calibration file not found at: {calibration_file_path}.")[m
[31m-                raise FileNotFoundError(f"MANUAL Calibration file not found: {calibration_file_path}")[m
[31m-            with open(calibration_file_path, 'r') as f:[m
[31m-                self.calibration_data = json.load(f)[m
[31m-            self.get_logger().info(f"MANUAL Calibration data loaded from: {calibration_file_path}")[m
[31m-            # Basic validation of calibration file content[m
[31m-            expected_keys = ["motor_names", "homing_offset", "drive_mode", "calib_mode", "start_pos", "end_pos"][m
[31m-            if not all(k in self.calibration_data for k in expected_keys):[m
[31m-                 self.get_logger().error("MANUAL Calibration file missing required keys!")[m
[31m-                 raise ValueError("Invalid MANUAL calibration file structure.")[m
[31m-            if self.calibration_data.get("motor_names") != MOTOR_NAMES_ORDER:[m
[31m-                 self.get_logger().error("Motor order mismatch in MANUAL calibration file!")[m
[31m-                 raise ValueError("Motor order mismatch in MANUAL calibration file.")[m
[31m-[m
[31m-            # 2. Connect to Motor Bus[m
[31m-            leader_config = FeetechMotorsBusConfig(port=LEADER_ARM_PORT, motors=LEADER_ARM_MOTORS)[m
[31m-            self.leader_bus_instance = FeetechMotorsBus(leader_config)[m
[31m-            self.get_logger().info(f"Connecting to bus on {LEADER_ARM_PORT}...")[m
[31m-            self.leader_bus_instance.connect()[m
[31m-            self.port_handler = self.leader_bus_instance.port_handler[m
[31m-            self.packet_handler = self.leader_bus_instance.packet_handler[m
[31m-            if self.port_handler is None or self.packet_handler is None:[m
[31m-                 raise RuntimeError("Failed to get valid port/packet handlers.")[m
[31m-            self.get_logger().info("Successfully connected to motor bus.")[m
[31m-[m
[31m-            # 3. Configure Status Return Level = 0 for controlled motors[m
[31m-            addr_ret_level = SCS_CONTROL_TABLE["Status_Return_Level"][0][m
[31m-            self.get_logger().info(f"Setting Status Return Level to 0 for motors: {MOTORS_TO_COMMAND}...")[m
[31m-            for name in MOTORS_TO_COMMAND:[m
[31m-                 if name not in LEADER_ARM_MOTORS: continue[m
[31m-                 motor_id = LEADER_ARM_MOTORS[name][0][m
[31m-                 scs_comm_result, scs_error = self.packet_handler.write1ByteTxRx(self.port_handler, motor_id, addr_ret_level, 0)[m
[31m-                 if scs_comm_result != scs.COMM_SUCCESS or scs_error != 0:[m
[31m-                      self.get_logger().warn(f"Failed to set Status Return Level for {name}({motor_id}). Res:{scs_comm_result}, Err:{scs_error}")[m
[31m-                 time.sleep(0.02) # Short delay between configurations[m
[31m-[m
[31m-            # 4. Initialize GroupSyncWrite & GroupSyncRead[m
[31m-            addr_goal_pos, len_goal_pos = SCS_CONTROL_TABLE["Goal_Position"][m
[31m-            self.group_writer = GroupSyncWrite(self.port_handler, self.packet_handler, addr_goal_pos, len_goal_pos)[m
[31m-            if self.group_writer is None: raise RuntimeError("Failed to initialize GroupSyncWrite.")[m
[31m-            self.get_logger().info("GroupSyncWrite handler initialized.")[m
[31m-            [m
[31m-            addr_present_pos, len_present_pos = SCS_CONTROL_TABLE["Present_Position"][m
[31m-            self.group_reader = GroupSyncRead(self.port_handler, self.packet_handler, addr_present_pos, len_present_pos)[m
[31m-            if self.group_reader is None: raise RuntimeError("Failed to initialize GroupSyncRead.")[m
[31m-            self.get_logger().info("GroupSyncRead handler initialized.")[m
[31m-            [m
[31m-            self.reader_motors_ok = True[m
[31m-            self.group_reader.clearParam()[m
[31m-            for name in MOTORS_TO_COMMAND: # Only add motors we intend to read[m
[31m-                if name not in LEADER_ARM_MOTORS: continue[m
[31m-                motor_id = LEADER_ARM_MOTORS[name][0][m
[31m-                if not self.group_reader.addParam(motor_id):[m
[31m-                    self.get_logger().error(f"Initial GroupSyncRead addParam failed for {name}({motor_id})")[m
[31m-                    self.reader_motors_ok = False[m
[31m-            if not self.reader_motors_ok:[m
[31m-                 self.get_logger().error("Could not add all target motors to GroupSyncRead handler.")[m
[31m-[m
[31m-            # 5. Enable Torque & Set Initial Pose/Hold Target[m
[31m-            motors_to_init_torque = MOTORS_TO_COMMAND + ["wrist_flex"] # Include wrist for initial pose[m
[31m-            self.get_logger().info(f"Enabling torque for {motors_to_init_torque}...")[m
[31m-            addr_torque = SCS_CONTROL_TABLE["Torque_Enable"][0][m
[31m-            addr_goal_pos_init = SCS_CONTROL_TABLE["Goal_Position"][0] # For individual initial pos[m
[31m-            for name in motors_to_init_torque:[m
[31m-                if name not in LEADER_ARM_MOTORS: continue[m
[31m-                motor_id = LEADER_ARM_MOTORS[name][0][m
[31m-                # Attempt to enable torque[m
[31m-                scs_comm_result, scs_error = self.packet_handler.write1ByteTxRx(self.port_handler, motor_id, addr_torque, 1)[m
[31m-                if scs_comm_result != scs.COMM_SUCCESS or (scs_error != 0 and scs_error != 32): # Err 32 can mean "already enabled"[m
[31m-                     self.get_logger().warn(f"Torque enable for {name}({motor_id}) potentially failed. Res:{scs_comm_result}, Err:{scs_error}")[m
[31m-                time.sleep(0.05)[m
[31m-                # Set initial position for wrist_flex only, others will be set by hold logic[m
[31m-                if name == "wrist_flex":[m
[31m-                    target_steps_wrist_array = revert_calibration(np.array([INITIAL_WRIST_POS_DEG]), [name], self.calibration_data, LEADER_ARM_MOTORS)[m
[31m-                    if target_steps_wrist_array is not None:[m
[31m-                        target_steps_wrist = target_steps_wrist_array.item()[m
[31m-                        self.packet_handler.write2ByteTxRx(self.port_handler, motor_id, addr_goal_pos_init, target_steps_wrist)[m
[31m-                        time.sleep(0.5) # Allow wrist to reach initial pos[m
[31m-            [m
[31m-            # Initialize hold target based on INITIAL_HOLD_POSE_DEG[m
[31m-            self.get_logger().info(f"Calculating initial hold target pose: {INITIAL_HOLD_POSE_DEG} deg")[m
[31m-            initial_hold_steps = revert_calibration([m
[31m-                INITIAL_HOLD_POSE_DEG, MOTORS_TO_COMMAND, self.calibration_data, LEADER_ARM_MOTORS[m
[31m-            )[m
[31m-            if initial_hold_steps is not None:[m
[31m-                self.last_valid_target_angles = INITIAL_HOLD_POSE_DEG.copy()[m
[31m-                self.last_sent_target_steps = initial_hold_steps[m
[31m-                self.get_logger().info(f"Initial hold target set -> Angles: {np.round(self.last_valid_target_angles,1)}, Steps: {self.last_sent_target_steps}")[m
[31m-            else:[m
[31m-                self.get_logger().error("Failed to calculate initial hold steps. Hold logic might start passively.")[m
[31m-            self.get_logger().info("Motor init and initial pose setup complete.")[m
[31m-[m
[31m-            # --- 6. ROS Parameters ---[m
[31m-            # General Control Parameters[m
[31m-            self.declare_parameter('stop_threshold', 0.01) # Threshold for control signal magnitude to consider as "stop"[m
[31m-            self.declare_parameter('read_frequency_hz', 20.0) # Target frequency for reading motor states[m
[31m-[m
[31m-            # Pan Control Parameters[m
[31m-            self.declare_parameter('pan_increment_scale', 0.1) # Proportional gain for pan control[m
[31m-            self.declare_parameter('pan_angle_min', -110.0)[m
[31m-            self.declare_parameter('pan_angle_max', 110.0)[m
[31m-[m
[31m-            # Cartesian Y Target Limits (for IK input)[m
[31m-            self.declare_parameter('target_yw_min', -0.02) # Min Y cartesian target for IK[m
[31m-            self.declare_parameter('target_yw_max', 0.52)  # Max Y cartesian target for IK (previously 0.26)[m
[31m-[m
[31m-            # Software Joint Limits (for IK output clipping)[m
[31m-            self.declare_parameter('lift_min', 0.0)   # Min angle for shoulder_lift (ID2)[m
[31m-            self.declare_parameter('lift_max', 130.0)  # Max angle for shoulder_lift (ID2)[m
[31m-            self.declare_parameter('elbow_min', 0.0)  # Min angle for elbow_flex (ID3)[m
[31m-            self.declare_parameter('elbow_max', 110.0) # Max angle for elbow_flex (ID3)[m
[31m-            [m
[31m-            # PI Control for Global Vertical (Y Cartesian) Movement[m
[31m-            self.declare_parameter('kp_vertical_gain', -0.00027) # Proportional gain for Y cartesian error[m
[31m-            self.declare_parameter('ki_vertical_gain', -0.0001)  # Integral gain for Y cartesian error[m
[31m-            self.declare_parameter('integral_max_output', 0.05)  # Anti-windup: Max output from Y integral term[m
[31m-            self.declare_parameter('integral_min_output', -0.05) # Anti-windup: Min output from Y integral term[m
[31m-[m
[31m-            # PI Control for ID2 (Shoulder/Lift) Angular Compensation[m
[31m-            self.declare_parameter('kp_angular_comp_id2', 0.008)   # Proportional gain for ID2 angular error[m
[31m-            self.declare_parameter('ki_angular_comp_id2', 0.00025)  # Integral gain for ID2 angular error[m
[31m-            self.declare_parameter('integral_angular_comp_id2_max_output_adj', 3.0) # Anti-windup: Max angle adjustment (deg)[m
[31m-            self.declare_parameter('integral_angular_comp_id2_min_output_adj', -3.0)# Anti-windup: Min angle adjustment (deg)[m
[31m-[m
[31m-            # Retrieve parameter values[m
[31m-            self.stop_threshold = self.get_parameter('stop_threshold').get_parameter_value().double_value[m
[31m-            read_frequency = self.get_parameter('read_frequency_hz').get_parameter_value().double_value[m
[31m-            self.read_period = 1.0 / read_frequency if read_frequency > 0 else 0.0[m
[31m-[m
[31m-            self.pan_increment_scale = self.get_parameter('pan_increment_scale').get_parameter_value().double_value[m
[31m-            self.pan_min = self.get_parameter('pan_angle_min').get_parameter_value().double_value[m
[31m-            self.pan_max = self.get_parameter('pan_angle_max').get_parameter_value().double_value[m
[31m-[m
[31m-            self.Y_MIN_LIMIT = self.get_parameter('target_yw_min').get_parameter_value().double_value[m
[31m-            self.Y_MAX_LIMIT = self.get_parameter('target_yw_max').get_parameter_value().double_value[m
[31m-            self.lift_min = self.get_parameter('lift_min').get_parameter_value().double_value[m
[31m-            self.lift_max = self.get_parameter('lift_max').get_parameter_value().double_value[m
[31m-            self.elbow_min = self.get_parameter('elbow_min').get_parameter_value().double_value[m
[31m-            self.elbow_max = self.get_parameter('elbow_max').get_parameter_value().double_value[m
[31m-[m
[31m-            self.Kp_y_cartesian = self.get_parameter('kp_vertical_gain').get_parameter_value().double_value[m
[31m-            self.Ki_y_cartesian = self.get_parameter('ki_vertical_gain').get_parameter_value().double_value[m
[31m-            self.integral_y_cartesian_max_output_val = self.get_parameter('integral_max_output').get_parameter_value().double_value[m
[31m-            self.integral_y_cartesian_min_output_val = self.get_parameter('integral_min_output').get_parameter_value().double_value[m
[31m-            [m
[31m-            self.Kp_angular_comp_ID2 = self.get_parameter('kp_angular_comp_id2').get_parameter_value().double_value[m
[31m-            self.Ki_angular_comp_ID2 = self.get_parameter('ki_angular_comp_id2').get_parameter_value().double_value[m
[31m-            self.integral_angular_comp_ID2_max_output_adj_val = self.get_parameter('integral_angular_comp_id2_max_output_adj').get_parameter_value().double_value[m
[31m-            self.integral_angular_comp_ID2_min_output_adj_val = self.get_parameter('integral_angular_comp_id2_min_output_adj').get_parameter_value().double_value[m
[32m+[m[32m            self._load_calibration_file()[m
[32m+[m[32m            self._connect_motor_bus()[m
[32m+[m[32m            self._configure_motors_srl()[m
[32m+[m[32m            self._initialize_group_sync_handlers()[m
[32m+[m[32m            self._initialize_motors_torque_and_pose()[m
[32m+[m[32m            self._declare_and_get_ros_parameters()[m
             [m
[31m-            # Initialize PI controller state variables[m
[31m-            self.integral_accumulator_y_cartesian = 0.0[m
[31m-            self.last_y_cartesian_control_time = self.get_clock().now()[m
[31m-            self.integral_accumulator_angle_id2 = 0.0[m
[31m-            self.last_comp_angle_id2_time = self.get_clock().now()[m
[31m-[m
[31m-            # Log parameters[m
[31m-            self.get_logger().info(f"Pan Scale: {self.pan_increment_scale:.4f}, Limits: [{self.pan_min:.1f}, {self.pan_max:.1f}] deg")[m
[31m-            self.get_logger().info(f"Vertical Cartesian Gains: Kp_y={self.Kp_y_cartesian:.5f}, Ki_y={self.Ki_y_cartesian:.5f}")[m
[31m-            self.get_logger().info(f"Vertical Cartesian Integral Output Limits: [{self.integral_y_cartesian_min_output_val:.3f}, {self.integral_y_cartesian_max_output_val:.3f}]")[m
[31m-            self.get_logger().info(f"YW Target Limits (Cartesian for IK): [{self.Y_MIN_LIMIT:.3f}, {self.Y_MAX_LIMIT:.3f}] m")[m
[31m-            self.get_logger().info(f"ID2 Ang. Comp. Gains: Kp_comp={self.Kp_angular_comp_ID2:.4f}, Ki_comp={self.Ki_angular_comp_ID2:.4f}")[m
[31m-            self.get_logger().info(f"ID2 Ang. Comp. Integral Adj Limits: [{self.integral_angular_comp_ID2_min_output_adj_val:.2f}, {self.integral_angular_comp_ID2_max_output_adj_val:.2f}] deg")[m
[31m-            self.get_logger().info(f"Software Joint Limits: Lift=[{self.lift_min:.1f}, {self.lift_max:.1f}], Elbow=[{self.elbow_min:.1f}, {self.elbow_max:.1f}] deg")[m
[31m-            self.get_logger().info(f"Stop Threshold: {self.stop_threshold:.3f}, Read Frequency: {read_frequency:.1f} Hz")[m
[31m-[m
[31m-            # Subscriber for control signals[m
[32m+[m[32m            self.joint_state_publisher = self.create_publisher(JointState, '/joint_states', 10)[m
             self.control_signal_subscription = self.create_subscription([m
                 Vector3, '/robot_control_signal', self.control_signal_callback, 10[m
             )[m
[31m-            self.get_logger().info('Subscribed to /robot_control_signal')[m
[32m+[m[32m            self.get_logger().info('Successfully subscribed to /robot_control_signal and created /joint_states publisher.')[m
 [m
         except Exception as e_init:[m
             self.get_logger().fatal(f"CRITICAL ERROR during node initialization: {e_init}")[m
             traceback.print_exc()[m
[31m-            self.cleanup_resources() # Attempt cleanup before re-raising[m
[32m+[m[32m            self.cleanup_resources()[m
             raise RuntimeError("Node initialization failed") from e_init[m
 [m
[32m+[m[32m    def _load_calibration_file(self):[m
[32m+[m[32m        try:[m
[32m+[m[32m            package_share_directory = get_package_share_directory(PACKAGE_NAME)[m
[32m+[m[32m            calibration_file_path = Path(package_share_directory) / 'config' / DEFAULT_CALIBRATION_FILENAME[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            self.get_logger().fatal(f"Could not find package share directory '{PACKAGE_NAME}' or construct path: {e}")[m
[32m+[m[32m            raise RuntimeError("Failed to get calibration file path") from e[m
[32m+[m[41m        [m
[32m+[m[32m        if not calibration_file_path.exists():[m
[32m+[m[32m            self.get_logger().error(f"Calibration file not found: {calibration_file_path}.")[m
[32m+[m[32m            raise FileNotFoundError(f"Calibration file not found: {calibration_file_path}")[m
[32m+[m[32m        with open(calibration_file_path, 'r') as f:[m
[32m+[m[32m            self.calibration_data = json.load(f)[m
[32m+[m[32m        self.get_logger().info(f"Calibration data loaded from: {calibration_file_path}")[m
[32m+[m[41m        [m
[32m+[m[32m        expected_keys = ["motor_names", "homing_offset", "drive_mode", "calib_mode", "start_pos", "end_pos"][m
[32m+[m[32m        if not all(k in self.calibration_data for k in expected_keys):[m
[32m+[m[32m             self.get_logger().error("Calibration file missing required keys. Check structure.")[m
[32m+[m[32m             raise ValueError("Invalid calibration file structure.")[m
[32m+[m[32m        if self.calibration_data.get("motor_names") != MOTOR_NAMES_ORDER:[m
[32m+[m[32m             self.get_logger().error("Motor order mismatch in calibration file vs. MOTOR_NAMES_ORDER.")[m
[32m+[m[32m             raise ValueError("Motor order mismatch in calibration file.")[m
[32m+[m
[32m+[m[32m    def _connect_motor_bus(self):[m
[32m+[m[32m        leader_config = FeetechMotorsBusConfig(port=LEADER_ARM_PORT, motors=LEADER_ARM_MOTORS)[m
[32m+[m[32m        self.leader_bus_instance = FeetechMotorsBus(leader_config)[m
[32m+[m[32m        self.get_logger().info(f"Connecting to bus on {LEADER_ARM_PORT}...")[m
[32m+[m[32m        self.leader_bus_instance.connect()[m
[32m+[m[32m        self.port_handler = self.leader_bus_instance.port_handler[m
[32m+[m[32m        self.packet_handler = self.leader_bus_instance.packet_handler[m
[32m+[m[32m        if self.port_handler is None or self.packet_handler is None:[m
[32m+[m[32m             raise RuntimeError("Failed to get valid port/packet handlers from FeetechMotorsBus.")[m
[32m+[m[32m        self.get_logger().info("Successfully connected to motor bus.")[m
[32m+[m
[32m+[m[32m    def _configure_motors_srl(self):[m
[32m+[m[32m        addr_ret_level = SCS_CONTROL_TABLE["Status_Return_Level"][0][m
[32m+[m[32m        self.get_logger().info(f"Setting Status Return Level to 0 for motors: {MOTOR_NAMES_ORDER}...")[m
[32m+[m[32m        # Setting SRL for all motors defined in LEADER_ARM_MOTORS for robustness[m
[32m+[m[32m        for name in MOTOR_NAMES_ORDER:[m[41m [m
[32m+[m[32m             if name not in LEADER_ARM_MOTORS: continue[m
[32m+[m[32m             motor_id = LEADER_ARM_MOTORS[name][0][m
[32m+[m[32m             scs_comm_result, scs_error = self.packet_handler.write1ByteTxRx(self.port_handler, motor_id, addr_ret_level, 0)[m
[32m+[m[32m             if scs_comm_result != scs.COMM_SUCCESS or scs_error != 0:[m
[32m+[m[32m                  self.get_logger().warn(f"Failed to set Status Return Level for {name}(ID:{motor_id}). Res:{scs_comm_result}, Err:{scs_error}")[m
[32m+[m[32m             time.sleep(0.01) # Small delay[m
[32m+[m
[32m+[m[32m    def _initialize_group_sync_handlers(self):[m
[32m+[m[32m        addr_goal_pos, len_goal_pos = SCS_CONTROL_TABLE["Goal_Position"][m
[32m+[m[32m        self.group_writer = GroupSyncWrite(self.port_handler, self.packet_handler, addr_goal_pos, len_goal_pos)[m
[32m+[m[32m        if self.group_writer is None: raise RuntimeError("Failed to initialize GroupSyncWrite.")[m
[32m+[m[32m        self.get_logger().info("GroupSyncWrite handler initialized.")[m
[32m+[m[41m        [m
[32m+[m[32m        addr_present_pos, len_present_pos = SCS_CONTROL_TABLE["Present_Position"][m
[32m+[m[32m        self.group_reader = GroupSyncRead(self.port_handler, self.packet_handler, addr_present_pos, len_present_pos)[m
[32m+[m[32m        if self.group_reader is None: raise RuntimeError("Failed to initialize GroupSyncRead.")[m
[32m+[m[32m        self.get_logger().info("GroupSyncRead handler initialized.")[m
[32m+[m[41m        [m
[32m+[m[32m        self.reader_motors_ok = True[m
[32m+[m[32m        self.group_reader.clearParam()[m
[32m+[m[32m        # Add all motors we might want to read (currently MOTORS_TO_COMMAND)[m
[32m+[m[32m        for name in MOTORS_TO_COMMAND:[m[41m [m
[32m+[m[32m            if name not in LEADER_ARM_MOTORS: continue[m
[32m+[m[32m            motor_id = LEADER_ARM_MOTORS[name][0][m
[32m+[m[32m            if not self.group_reader.addParam(motor_id):[m
[32m+[m[32m                self.get_logger().error(f"Initial GroupSyncRead addParam failed for {name}(ID:{motor_id})")[m
[32m+[m[32m                self.reader_motors_ok = False[m
[32m+[m[32m        if not self.reader_motors_ok:[m
[32m+[m[32m             self.get_logger().error("Could not add all MOTORS_TO_COMMAND to GroupSyncRead handler.")[m
[32m+[m[32m             # This might not be fatal if control logic can handle missing reads, but it's a problem.[m
[32m+[m
[32m+[m[32m    def _initialize_motors_torque_and_pose(self):[m
[32m+[m[32m        motors_to_init_torque = MOTOR_NAMES_ORDER # Enable torque for all motors[m
[32m+[m[32m        self.get_logger().info(f"Enabling torque for: {motors_to_init_torque}...")[m
[32m+[m[32m        addr_torque = SCS_CONTROL_TABLE["Torque_Enable"][0][m
[32m+[m[32m        addr_goal_pos_init = SCS_CONTROL_TABLE["Goal_Position"][0][m
[32m+[m[41m        [m
[32m+[m[32m        for name in motors_to_init_torque:[m
[32m+[m[32m            if name not in LEADER_ARM_MOTORS: continue[m
[32m+[m[32m            motor_id = LEADER_ARM_MOTORS[name][0][m
[32m+[m[32m            scs_comm_result, scs_error = self.packet_handler.write1ByteTxRx(self.port_handler, motor_id, addr_torque, 1)[m
[32m+[m[32m            if scs_comm_result != scs.COMM_SUCCESS or (scs_error != 0 and scs_error != 32):[m
[32m+[m[32m                 self.get_logger().warn(f"Torque enable for {name}(ID:{motor_id}) potentially failed. Res:{scs_comm_result}, Err:{scs_error}")[m
[32m+[m[32m            time.sleep(0.02)[m
[32m+[m[41m            [m
[32m+[m[32m            # Set initial position for wrist_flex separately if needed (and if it's not in MOTORS_TO_COMMAND for main hold)[m
[32m+[m[32m            if name == "wrist_flex" and name not in MOTORS_TO_COMMAND:[m
[32m+[m[32m                target_steps_wrist_array = revert_calibration(np.array([INITIAL_WRIST_POS_DEG]), [name], self.calibration_data, LEADER_ARM_MOTORS)[m
[32m+[m[32m                if target_steps_wrist_array is not None:[m
[32m+[m[32m                    target_steps_wrist = target_steps_wrist_array.item()[m
[32m+[m[32m                    self.packet_handler.write2ByteTxRx(self.port_handler, motor_id, addr_goal_pos_init, target_steps_wrist)[m
[32m+[m[32m                    time.sleep(0.1) # Allow wrist to reach initial pos[m
[32m+[m[41m        [m
[32m+[m[32m        self.get_logger().info(f"Calculating initial hold target pose for controlled motors: {INITIAL_HOLD_POSE_DEG} deg")[m
[32m+[m[32m        initial_hold_steps = revert_calibration([m
[32m+[m[32m            INITIAL_HOLD_POSE_DEG, MOTORS_TO_COMMAND, self.calibration_data, LEADER_ARM_MOTORS[m
[32m+[m[32m        )[m
[32m+[m[32m        if initial_hold_steps is not None:[m
[32m+[m[32m            self.last_valid_target_angles = INITIAL_HOLD_POSE_DEG.copy()[m
[32m+[m[32m            self.last_sent_target_steps = initial_hold_steps[m
[32m+[m[32m            self.get_logger().info(f"Initial hold target for controlled motors set -> Angles: {np.round(self.last_valid_target_angles,1)}, Steps: {self.last_sent_target_steps}")[m
[32m+[m[32m        else:[m
[32m+[m[32m            self.get_logger().error("Failed to calculate initial hold steps. Hold logic might start passively.")[m
[32m+[m[32m        self.get_logger().info("Motor torque and initial pose setup complete.")[m
[32m+[m
[32m+[m[32m    def _declare_and_get_ros_parameters(self):[m
[32m+[m[32m        # General Control Parameters[m
[32m+[m[32m        self.declare_parameter('stop_threshold', 0.01)[m
[32m+[m[32m        self.declare_parameter('read_frequency_hz', 20.0)[m
[32m+[m[32m        self.stop_threshold = self.get_parameter('stop_threshold').get_parameter_value().double_value[m
[32m+[m[32m        read_frequency = self.get_parameter('read_frequency_hz').get_parameter_value().double_value[m
[32m+[m[32m        self.read_period = 1.0 / read_frequency if read_frequency > 0 else 0.0 # Avoid division by zero[m
[32m+[m
[32m+[m[32m        # Pan Control Parameters[m
[32m+[m[32m        self.declare_parameter('pan_increment_scale', 0.1)[m
[32m+[m[32m        self.declare_parameter('pan_angle_min', -110.0)[m
[32m+[m[32m        self.declare_parameter('pan_angle_max', 110.0)[m
[32m+[m[32m        self.pan_increment_scale = self.get_parameter('pan_increment_scale').get_parameter_value().double_value[m
[32m+[m[32m        self.pan_min = self.get_parameter('pan_angle_min').get_parameter_value().double_value[m
[32m+[m[32m        self.pan_max = self.get_parameter('pan_angle_max').get_parameter_value().double_value[m
[32m+[m
[32m+[m[32m        # Cartesian Y Target Limits for IK input[m
[32m+[m[32m        self.declare_parameter('target_yw_min', -0.02)[m
[32m+[m[32m        self.declare_parameter('target_yw_max', 0.52)[m
[32m+[m[32m        self.Y_MIN_LIMIT = self.get_parameter('target_yw_min').get_parameter_value().double_value[m
[32m+[m[32m        self.Y_MAX_LIMIT = self.get_parameter('target_yw_max').get_parameter_value().double_value[m
[32m+[m
[32m+[m[32m        # Software Joint Limits for IK output clipping (degrees)[m
[32m+[m[32m        self.declare_parameter('lift_min', 0.0)[m
[32m+[m[32m        self.declare_parameter('lift_max', 130.0)[m
[32m+[m[32m        self.declare_parameter('elbow_min', 0.0)[m
[32m+[m[32m        self.declare_parameter('elbow_max', 110.0)[m
[32m+[m[32m        self.lift_min = self.get_parameter('lift_min').get_parameter_value().double_value[m
[32m+[m[32m        self.lift_max = self.get_parameter('lift_max').get_parameter_value().double_value[m
[32m+[m[32m        self.elbow_min = self.get_parameter('elbow_min').get_parameter_value().double_value[m
[32m+[m[32m        self.elbow_max = self.get_parameter('elbow_max').get_parameter_value().double_value[m
[32m+[m[41m        [m
[32m+[m[32m        # PI Control for Global Vertical (Y Cartesian) Movement[m
[32m+[m[32m        self.declare_parameter('kp_vertical_gain', -0.00027)[m
[32m+[m[32m        self.declare_parameter('ki_vertical_gain', -0.00010)[m
[32m+[m[32m        self.declare_parameter('integral_max_output', 0.05)[m
[32m+[m[32m        self.declare_parameter('integral_min_output', -0.05)[m
[32m+[m[32m        self.Kp_y_cartesian = self.get_parameter('kp_vertical_gain').get_parameter_value().double_value[m
[32m+[m[32m        self.Ki_y_cartesian = self.get_parameter('ki_vertical_gain').get_parameter_value().double_value[m
[32m+[m[32m        self.integral_y_cartesian_max_output_val = self.get_parameter('integral_max_output').get_parameter_value().double_value[m
[32m+[m[32m        self.integral_y_cartesian_min_output_val = self.get_parameter('integral_min_output').get_parameter_value().double_value[m
[32m+[m[41m        [m
[32m+[m[32m        # PI Control for ID2 (Shoulder/Lift) Angular Compensation[m
[32m+[m[32m        self.declare_parameter('kp_angular_comp_id2', 0.0080)[m
[32m+[m[32m        self.declare_parameter('ki_angular_comp_id2', 0.00025) # Corrected from 0.0003 to 0.00025 as per log[m
[32m+[m[32m        self.declare_parameter('integral_angular_comp_id2_max_output_adj', 3.0)[m
[32m+[m[32m        self.declare_parameter('integral_angular_comp_id2_min_output_adj', -3.0)[m
[32m+[m[32m        self.Kp_angular_comp_ID2 = self.get_parameter('kp_angular_comp_id2').get_parameter_value().double_value[m
[32m+[m[32m        self.Ki_angular_comp_ID2 = self.get_parameter('ki_angular_comp_id2').get_parameter_value().double_value[m
[32m+[m[32m        self.integral_angular_comp_ID2_max_output_adj_val = self.get_parameter('integral_angular_comp_id2_max_output_adj').get_parameter_value().double_value[m
[32m+[m[32m        self.integral_angular_comp_ID2_min_output_adj_val = self.get_parameter('integral_angular_comp_id2_min_output_adj').get_parameter_value().double_value[m
[32m+[m[41m        [m
[32m+[m[32m        # Initialize PI controller state variables[m
[32m+[m[32m        self.integral_accumulator_y_cartesian = 0.0[m
[32m+[m[32m        self.last_y_cartesian_control_time = self.get_clock().now()[m
[32m+[m[32m        self.integral_accumulator_angle_id2 = 0.0[m
[32m+[m[32m        self.last_comp_angle_id2_time = self.get_clock().now()[m
[32m+[m
[32m+[m[32m        self.get_logger().info("ROS Parameters loaded.")[m
[32m+[m[32m        # Parameters are logged individually if needed by their respective logic blocks.[m
[32m+[m
     def cleanup_resources(self):[m
         self.get_logger().info("Attempting resource cleanup...")[m
         if self.leader_bus_instance is not None and getattr(self.leader_bus_instance, 'is_connected', False):[m
[36m@@ -453,32 +468,22 @@[m [mclass RealRobotInterfaceNode(Node):[m
                   self.get_logger().error(f"Error closing port handler directly: {e_close}")[m
         else:[m
              self.get_logger().info("No active bus/port connection found to clean up.")[m
[31m-        self.port_handler = None # Ensure handlers are None after cleanup[m
[32m+[m[32m        self.port_handler = None[m
         self.packet_handler = None[m
         self.group_writer = None[m
         self.group_reader = None[m
 [m
[31m-    def send_goal_positions(self, names: list[str], steps: np.ndarray) -> bool:[m
[31m-        """Sends goal positions to specified motors using GroupSyncWrite."""[m
[32m+[m[32m    def send_goal_positions(self, motor_names_to_send: list[str], steps_to_send: np.ndarray) -> bool:[m
         if self.group_writer is None: [m
             self.get_logger().error("GroupSyncWrite handler not initialized.", throttle_duration_sec=5)[m
             return False[m
         [m
[31m-        # Ensure steps are within the absolute motor limits [0, 4095][m
[31m-        steps_final_clipped = np.clip(steps, 0, 4095).astype(np.int32)[m
[31m-        if not np.array_equal(steps, steps_final_clipped):[m
[31m-             # Log if any step was outside the absolute [0,4095] range before this final clip[m
[31m-             diff_indices = np.where(steps != steps_final_clipped)[0][m
[31m-             for idx in diff_indices:[m
[31m-                  self.get_logger().error([m
[31m-                      f"Motor {names[idx]}: Step {steps[idx]} was outside [0, 4095] before final send. Clipped to {steps_final_clipped[idx]}.", [m
[31m-                      throttle_duration_sec=5.0[m
[31m-                    )[m
[31m-[m
[32m+[m[32m        steps_final_clipped = np.clip(steps_to_send, 0, MODEL_RESOLUTION["sts3215"] - 1).astype(np.int32)[m
[32m+[m[41m        [m
         self.group_writer.clearParam()[m
         success_add = True[m
[31m-        for i, name in enumerate(names):[m
[31m-            if name not in LEADER_ARM_MOTORS: continue # Should not happen if MOTORS_TO_COMMAND is used[m
[32m+[m[32m        for i, name in enumerate(motor_names_to_send):[m
[32m+[m[32m            if name not in LEADER_ARM_MOTORS: continue[m
             motor_id = LEADER_ARM_MOTORS[name][0][m
             step_value = int(steps_final_clipped[i])[m
             param = [scs.SCS_LOBYTE(step_value), scs.SCS_HIBYTE(step_value)][m
[36m@@ -490,42 +495,78 @@[m [mclass RealRobotInterfaceNode(Node):[m
         [m
         comm_result = self.group_writer.txPacket()[m
         if comm_result != scs.COMM_SUCCESS:[m
[31m-            error_msg = f"GroupSyncWrite txPacket error code: {comm_result}"[m
[31m-            # Attempt to get more descriptive error if packet_handler supports it[m
[31m-            if hasattr(self.packet_handler, 'getTxRxResult'):[m
[31m-                 try: error_msg = f"GroupSyncWrite txPacket error: {self.packet_handler.getTxRxResult(comm_result)}"[m
[31m-                 except Exception: pass # Keep generic error if getTxRxResult fails[m
[31m-            self.get_logger().error(error_msg, throttle_duration_sec=1.0)[m
[32m+[m[32m            error_msg_detail = self.packet_handler.getTxRxResult(comm_result) if hasattr(self.packet_handler, 'getTxRxResult') else f"Code: {comm_result}"[m
[32m+[m[32m            self.get_logger().error(f"GroupSyncWrite txPacket error: {error_msg_detail}", throttle_duration_sec=1.0)[m
             return False[m
         return True[m
 [m
[31m-    def control_signal_callback(self, msg: Vector3):[m
[31m-        # start_time_loop = self.get_clock().now() # For detailed loop timing if needed[m
[32m+[m[32m    def _publish_joint_states(self, calibrated_angles_deg_ordered: np.ndarray):[m
[32m+[m[32m        """Publishes the current joint states for RViz visualization."""[m
[32m+[m[32m        joint_state_msg = JointState()[m
[32m+[m[32m        joint_state_msg.header.stamp = self.get_clock().now().to_msg()[m
[32m+[m[32m        joint_state_msg.name = self.joint_names_urdf_order # ['Rotation', 'Pitch', ..., 'Jaw'][m
[32m+[m[41m        [m
[32m+[m[32m        # Initialize positions for all URDF joints (some might not be actively read)[m
[32m+[m[32m        positions_for_urdf = [0.0] * len(self.joint_names_urdf_order)[m
 [m
[31m-        # Ensure node and SDK are ready[m
[32m+[m[32m        # Map read/calibrated angles (ordered by MOTORS_TO_COMMAND) to URDF joint order[m
[32m+[m[32m        angles_lus_map_rad = {}[m
[32m+[m[32m        current_angles_rad_calibrated = np.radians(calibrated_angles_deg_ordered)[m
[32m+[m[32m        for i, motor_name_internal in enumerate(MOTORS_TO_COMMAND):[m
[32m+[m[32m            angles_lus_map_rad[motor_name_internal] = current_angles_rad_calibrated[i][m
[32m+[m
[32m+[m[32m        for i, urdf_joint_name in enumerate(self.joint_names_urdf_order):[m
[32m+[m[32m            current_motor_angle_rad = 0.0 # Default if not actively read[m
[32m+[m[41m            [m
[32m+[m[32m            # Find the internal motor name corresponding to this URDF joint[m
[32m+[m[32m            internal_motor_name_for_urdf = None[m
[32m+[m[32m            for motor_internal_map_key, urdf_mapped_val in self.active_motor_names_map.items():[m
[32m+[m[32m                if urdf_mapped_val == urdf_joint_name:[m
[32m+[m[32m                    internal_motor_name_for_urdf = motor_internal_map_key[m
[32m+[m[32m                    break[m
[32m+[m[41m            [m
[32m+[m[32m            if internal_motor_name_for_urdf and internal_motor_name_for_urdf in angles_lus_map_rad:[m
[32m+[m[32m                # This joint's angle was read from MOTORS_TO_COMMAND[m
[32m+[m[32m                current_motor_angle_rad = angles_lus_map_rad[internal_motor_name_for_urdf][m
[32m+[m[41m            [m
[32m+[m[32m            # Apply the defined offset for this URDF joint[m
[32m+[m[32m            # Offset defines the URDF zero pose relative to the calibrated motor zero[m
[32m+[m[32m            angle_to_publish = current_motor_angle_rad + self.joint_offsets_rad.get(urdf_joint_name, 0.0)[m
[32m+[m[41m            [m
[32m+[m[32m            # Apply specific inversion for 'Pitch' joint (ID2 / shoulder_lift)[m
[32m+[m[32m            # This ensures the motion in RViz matches the physical robot's "up" direction[m
[32m+[m[32m            if urdf_joint_name == self.active_motor_names_map.get("shoulder_lift"): # "Pitch"[m
[32m+[m[32m                angle_to_publish *= -1.0[m
[32m+[m[41m            [m
[32m+[m[32m            positions_for_urdf[i] = float(angle_to_publish)[m
[32m+[m[41m            [m
[32m+[m[32m        joint_state_msg.position = positions_for_urdf[m
[32m+[m[32m        self.joint_state_publisher.publish(joint_state_msg)[m
[32m+[m
[32m+[m[32m    def control_signal_callback(self, msg: Vector3):[m
         if not (self.port_handler and self.packet_handler and self.calibration_data and \[m
                 self.group_writer and self.group_reader and self.reader_motors_ok):[m
[31m-            self.get_logger().warn("Node not fully initialized or reader setup failed, skipping command.", throttle_duration_sec=5)[m
[32m+[m[32m            self.get_logger().warn("Node components not fully initialized, skipping command.", throttle_duration_sec=5)[m
             return[m
[31m-        if scs is None: # Should have been caught in __init__[m
[32m+[m[32m        if scs is None:[m
             self.get_logger().error("scservo_sdk not loaded, cannot execute callback.", throttle_duration_sec=5)[m
             return[m
 [m
[31m-        signal_pan = msg.x  # Control signal for Pan movement[m
[31m-        signal_lift_y_cartesian = msg.y # Control signal for Y Cartesian movement (input to Y PI controller)[m
[32m+[m[32m        signal_pan = msg.x[m
[32m+[m[32m        signal_lift_y_cartesian = msg.y[m
 [m
         # --- 1. Read Current Motor State (Throttled) ---[m
         raw_positions_np = None[m
         read_attempted_this_cycle = False[m
         current_callback_time = self.get_clock().now()[m
[32m+[m
         if self.read_period <= 0 or (current_callback_time - self.last_read_time).nanoseconds / 1e9 >= self.read_period:[m
              read_attempted_this_cycle = True[m
              self.last_read_time = current_callback_time[m
              try:[m
                  comm_result = self.group_reader.txRxPacket()[m
                  if comm_result != scs.COMM_SUCCESS:[m
[31m-                     # Log read error, but try to use last known position if available[m
[31m-                     self.get_logger().warn(f"GroupSyncRead txRxPacket error: {comm_result}", throttle_duration_sec=1.0)[m
[32m+[m[32m                     self.get_logger().warn(f"GroupSyncRead txRxPacket error. Using last known positions.", throttle_duration_sec=1.0)[m
                  else:[m
                      addr_present_pos, len_present_pos = SCS_CONTROL_TABLE["Present_Position"][m
                      temp_raw_list = [][m
[36m@@ -536,61 +577,62 @@[m [mclass RealRobotInterfaceNode(Node):[m
                                value = self.group_reader.getData(motor_id, addr_present_pos, len_present_pos)[m
                                temp_raw_list.append(np.int32(value))[m
                           else:[m
[31m-                               self.get_logger().warn(f"Data not available for {motor_name_to_read}({motor_id}) after GroupSyncRead.", throttle_duration_sec=1.0)[m
[31m-                               temp_raw_list.append(np.nan) # Mark as NaN if not available[m
[32m+[m[32m                               self.get_logger().warn(f"Data not available for {motor_name_to_read}(ID:{motor_id}) after GroupSyncRead. Using last known.", throttle_duration_sec=1.0)[m
[32m+[m[32m                               temp_raw_list.append(np.nan)[m
                                all_data_available_from_read = False[m
                      if all_data_available_from_read:[m
                          raw_positions_np = np.array(temp_raw_list, dtype=np.int32)[m
[31m-                         self.last_known_raw_positions = raw_positions_np # Update last known good read[m
[32m+[m[32m                         self.last_known_raw_positions = raw_positions_np[m
[32m+[m[32m                     # If not all data available, raw_positions_np remains None for this cycle[m
              except Exception as e_read_stage:[m
[31m-                 self.get_logger().error(f"Exception during GroupSyncRead stage: {e_read_stage}")[m
[32m+[m[32m                 self.get_logger().error(f"Exception during GroupSyncRead: {e_read_stage}")[m
         [m
[31m-        # Use last known positions if current read failed or was skipped[m
         if raw_positions_np is None:[m
             if self.last_known_raw_positions is not None:[m
                 raw_positions_np = self.last_known_raw_positions[m
[31m-                if read_attempted_this_cycle: self.get_logger().warn("Using last known motor positions due to current read failure/issue.")[m
[32m+[m[32m                if read_attempted_this_cycle: self.get_logger().debug("Using last known motor positions due to current read issue.")[m
             else:[m
[31m-                self.get_logger().error("No current or previous motor state available. Cannot proceed with control.")[m
[31m-                return # Critical: cannot control without knowing current state[m
[32m+[m[32m                self.get_logger().error("No current or previous motor state available. Cannot proceed.")[m
[32m+[m[32m                return[m
 [m
[31m-        # --- 2. Apply Calibration to Get Current Angles ---[m
[32m+[m[32m        # --- 2. Apply Calibration to Get Current Angles for Controlled Motors ---[m
         try:[m
[32m+[m[32m            # calibrated_angles_deg will be ordered according to MOTORS_TO_COMMAND[m
             calibrated_angles_deg = apply_calibration([m
                 raw_positions_np, MOTORS_TO_COMMAND, self.calibration_data, LEADER_ARM_MOTORS[m
             )[m
             if calibrated_angles_deg is None or np.isnan(calibrated_angles_deg).any():[m
[31m-                self.get_logger().error(f"Apply_calibration failed. Raw:{raw_positions_np} -> Calib:{calibrated_angles_deg}. Skipping control.", throttle_duration_sec=1.0)[m
[31m-                # Attempt to hold last sent steps if calibration fails[m
[32m+[m[32m                self.get_logger().error(f"Apply_calibration failed. Raw:{raw_positions_np} -> Calib:{calibrated_angles_deg}. Holding.", throttle_duration_sec=1.0)[m
                 if self.last_sent_target_steps is not None:[m
                      if not self.send_goal_positions(MOTORS_TO_COMMAND, self.last_sent_target_steps):[m
                           self.get_logger().error("Failed to send hold command after calibration failure.")[m
                 return[m
             current_pan_deg = calibrated_angles_deg[0][m
[31m-            current_theta1_deg = calibrated_angles_deg[1] # Current Shoulder/Lift angle (ID2)[m
[31m-            current_theta2_deg = calibrated_angles_deg[2] # Current Elbow angle (ID3)[m
[32m+[m[32m            current_theta1_deg = calibrated_angles_deg[1] # Shoulder/Lift (ID2)[m
[32m+[m[32m            current_theta2_deg = calibrated_angles_deg[2] # Elbow (ID3)[m
         except Exception as e_apply_calib_stage:[m
[31m-            self.get_logger().error(f"Exception during apply_calibration stage: {e_apply_calib_stage}")[m
[32m+[m[32m            self.get_logger().error(f"Exception during apply_calibration: {e_apply_calib_stage}")[m
             return[m
 [m
[32m+[m[32m        # --- Publish Joint States for RViz (using angles of MOTORS_TO_COMMAND) ---[m
[32m+[m[32m        self._publish_joint_states(calibrated_angles_deg)[m
[32m+[m
         # --- 3. Calculate Target Angles (with Active Hold Logic and Control) ---[m
[31m-        # Initialize target angles with last valid ones (for hold) or current ones if no prior[m
         if self.last_valid_target_angles is not None:[m
              target_pan_deg = self.last_valid_target_angles[0][m
[31m-             target_theta1_deg = self.last_valid_target_angles[1] # Will be updated by IK + Compensation[m
[31m-             target_theta2_deg = self.last_valid_target_angles[2] # Will be updated by IK[m
[31m-        else: # Should only happen on first run if initial_hold_pose failed[m
[32m+[m[32m             target_theta1_deg = self.last_valid_target_angles[1][m
[32m+[m[32m             target_theta2_deg = self.last_valid_target_angles[2][m
[32m+[m[32m        else:[m
              target_pan_deg = current_pan_deg[m
              target_theta1_deg = current_theta1_deg[m
              target_theta2_deg = current_theta2_deg[m
         [m
         new_target_calculated_this_cycle = False[m
 [m
[31m-        # Pan Control (Proportional)[m
[32m+[m[32m        # Pan Control[m
         if abs(signal_pan) >= self.stop_threshold:[m
             delta_pan_deg = self.pan_increment_scale * signal_pan[m
[31m-            target_pan_deg = current_pan_deg + delta_pan_deg # Target is relative to current[m
[31m-            target_pan_deg = np.clip(target_pan_deg, self.pan_min, self.pan_max)[m
[32m+[m[32m            target_pan_deg = np.clip(current_pan_deg + delta_pan_deg, self.pan_min, self.pan_max)[m
             new_target_calculated_this_cycle = True[m
 [m
         # Vertical Control (Cartesian Y PI -> IK -> ID2 Angular Compensation PI)[m
[36m@@ -598,13 +640,10 @@[m [mclass RealRobotInterfaceNode(Node):[m
             try:[m
                 current_xw_fk, current_yw_fk = calculate_fk_wrist(current_theta1_deg, current_theta2_deg)[m
 [m
[31m-                # PI Control for Y Cartesian Target[m
                 time_y_pi = self.get_clock().now()[m
[31m-                dt_y_pi_duration = time_y_pi - self.last_y_cartesian_control_time[m
[31m-                dt_y_pi = dt_y_pi_duration.nanoseconds / 1e9 [m
[32m+[m[32m                dt_y_pi = (time_y_pi - self.last_y_cartesian_control_time).nanoseconds / 1e9[m[41m [m
                 self.last_y_cartesian_control_time = time_y_pi[m
 [m
[31m-                # signal_lift_y_cartesian: positive implies "target is visually higher, need to move Y up"[m
                 self.integral_accumulator_y_cartesian += signal_lift_y_cartesian * dt_y_pi[m
                 [m
                 p_contrib_y_cartesian = self.Kp_y_cartesian * signal_lift_y_cartesian[m
[36m@@ -617,28 +656,20 @@[m [mclass RealRobotInterfaceNode(Node):[m
                 delta_yw_cartesian_target = p_contrib_y_cartesian + i_contrib_y_cartesian_clipped[m
                 [m
                 target_yw_for_ik = current_yw_fk + delta_yw_cartesian_target[m
[31m-                target_xw_for_ik = current_xw_fk # Assume no X change from vertical control for now[m
[32m+[m[32m                target_xw_for_ik = current_xw_fk[m
 [m
[31m-                # Clip Cartesian Y target for IK[m
                 target_yw_for_ik_clipped = np.clip(target_yw_for_ik, self.Y_MIN_LIMIT, self.Y_MAX_LIMIT)[m
[31m-                if abs(target_yw_for_ik_clipped - target_yw_for_ik) > 1e-4:[m
[31m-                    self.get_logger().warn(f"CARTESIAN Y TARGET CLIPPED: Raw={target_yw_for_ik:.4f} -> Clipped={target_yw_for_ik_clipped:.4f}")[m
[31m-[m
[31m-                # Inverse Kinematics[m
[32m+[m[41m                [m
                 ik_theta1_rad, ik_theta2_rad, ik_ok = calculate_ik(target_xw_for_ik, target_yw_for_ik_clipped)[m
 [m
                 if ik_ok:[m
                     target_th1_deg_from_ik = math.degrees(ik_theta1_rad)[m
                     target_th2_deg_from_ik = math.degrees(ik_theta2_rad)[m
 [m
[31m-                    # --- ID2 (Shoulder/Lift) Angular PI Compensation ---[m
                     error_angle_id2 = target_th1_deg_from_ik - current_theta1_deg[m
[31m-                    [m
                     time_id2_comp = self.get_clock().now()[m
[31m-                    dt_id2_comp_duration = time_id2_comp - self.last_comp_angle_id2_time[m
[31m-                    dt_id2_comp = dt_id2_comp_duration.nanoseconds / 1e9[m
[32m+[m[32m                    dt_id2_comp = (time_id2_comp - self.last_comp_angle_id2_time).nanoseconds / 1e9[m
                     self.last_comp_angle_id2_time = time_id2_comp[m
[31m-[m
                     self.integral_accumulator_angle_id2 += error_angle_id2 * dt_id2_comp[m
                     [m
                     p_adj_id2 = self.Kp_angular_comp_ID2 * error_angle_id2[m
[36m@@ -651,33 +682,22 @@[m [mclass RealRobotInterfaceNode(Node):[m
                     total_angle_adjustment_id2 = p_adj_id2 + i_adj_id2_clipped[m
                     target_theta1_deg_compensated = target_th1_deg_from_ik + total_angle_adjustment_id2[m
                     [m
[31m-                    self.get_logger().info( # Keep this important log for ID2 compensation behavior[m
[31m-                        f"ID2 Ang.Comp: Err_th1={error_angle_id2:.1f}d, "[m
[31m-                        f"TotalAdj={total_angle_adjustment_id2:.1f}d, "[m
[31m-                        f"Th1_IK={target_th1_deg_from_ik:.1f}d -> Th1_Final={target_theta1_deg_compensated:.1f}d"[m
[32m+[m[32m                    self.get_logger().debug([m
[32m+[m[32m                        f"ID2 Ang.Comp: Err_th1={error_angle_id2:.1f}d, TotalAdj={total_angle_adjustment_id2:.1f}d, "[m
[32m+[m[32m                        f"Th1_IK={target_th1_deg_from_ik:.1f}d -> Th1_FinalComp={target_theta1_deg_compensated:.1f}d"[m
                     )[m
[31m-                    # --- End ID2 Angular PI Compensation ---[m
[31m-[m
[31m-                    # Apply software joint limits to final target angles[m
[31m-                    target_theta1_deg_final_clipped = np.clip(target_theta1_deg_compensated, self.lift_min, self.lift_max)[m
[31m-                    target_theta2_deg_final_clipped = np.clip(target_th2_deg_from_ik, self.elbow_min, self.elbow_max) # ID3 uses IK output directly[m
                     [m
[31m-                    if abs(target_theta1_deg_final_clipped - target_theta1_deg_compensated) > 0.1:[m
[31m-                         self.get_logger().warn(f"LIFT (ID2) ANGLE CLIPPED (Post-Comp): Comp={target_theta1_deg_compensated:.1f} -> SW Lim Clip: {target_theta1_deg_final_clipped:.1f}")[m
[31m-                    if abs(target_theta2_deg_final_clipped - target_th2_deg_from_ik) > 0.1: [m
[31m-                         self.get_logger().warn(f"ELBOW (ID3) ANGLE CLIPPED: IK Raw={target_th2_deg_from_ik:.1f} -> SW Lim Clip: {target_theta2_deg_final_clipped:.1f}")[m
[32m+[m[32m                    target_theta1_deg = np.clip(target_theta1_deg_compensated, self.lift_min, self.lift_max)[m
[32m+[m[32m                    target_theta2_deg = np.clip(target_th2_deg_from_ik, self.elbow_min, self.elbow_max)[m
                     [m
[31m-                    target_theta1_deg = target_theta1_deg_final_clipped[m
[31m-                    target_theta2_deg = target_theta2_deg_final_clipped[m
                     new_target_calculated_this_cycle = True[m
[31m-                else: # IK failed[m
[31m-                    self.get_logger().warn(f"IK FAILED for target X={target_xw_for_ik:.3f}, Y={target_yw_for_ik_clipped:.3f}. Holding angles.", throttle_duration_sec=1.0)[m
[31m-                    # Reset integrators if IK fails to prevent wind-up[m
[31m-                    self.integral_accumulator_y_cartesian = 0.0[m
[32m+[m[32m                else:[m[41m [m
[32m+[m[32m                    self.get_logger().warn(f"IK FAILED for target X={target_xw_for_ik:.3f}, Y={target_yw_for_ik_clipped:.3f}. Holding.", throttle_duration_sec=1.0)[m
[32m+[m[32m                    self.integral_accumulator_y_cartesian = 0.0 # Reset integrators[m
                     self.integral_accumulator_angle_id2 = 0.0[m
             except Exception as e_vertical_control:[m
[31m-                 self.get_logger().error(f"Exception during vertical control (FK/IK/Compensation) stage: {e_vertical_control}")[m
[31m-                 traceback.print_exc()[m
[32m+[m[32m                 self.get_logger().error(f"Exception during vertical control logic: {e_vertical_control}")[m
[32m+[m[32m                 # traceback.print_exc() # Uncomment for deep debugging[m
 [m
         # --- 4. Convert Final Target Angles to Steps and Send ---[m
         try:[m
[36m@@ -685,68 +705,62 @@[m [mclass RealRobotInterfaceNode(Node):[m
             target_steps = revert_calibration([m
                 final_target_angles_deg_np, MOTORS_TO_COMMAND, self.calibration_data, LEADER_ARM_MOTORS[m
             )[m
[31m-            if target_steps is None: # Should not happen if revert_calibration returns a default[m
[31m-                self.get_logger().error("Revert calibration returned None. Attempting to hold last sent steps.")[m
[32m+[m[32m            if target_steps is None:[m
[32m+[m[32m                self.get_logger().error("Revert calibration failed. Attempting to hold last sent steps.")[m
                 if self.last_sent_target_steps is not None:[m
                     target_steps = self.last_sent_target_steps[m
[31m-                else: # Critical failure if no steps to send[m
[31m-                     self.get_logger().error("Cannot hold: No previous steps stored. Skipping write command.")[m
[32m+[m[32m                else:[m
[32m+[m[32m                     self.get_logger().error("Cannot hold: No previous steps stored. Skipping command.")[m
                      return[m
             [m
[32m+[m[32m            log_level = self.get_logger().info if new_target_calculated_this_cycle else self.get_logger().debug[m
             log_prefix = "COMMAND (NEW TGT):" if new_target_calculated_this_cycle else "COMMAND (HOLDING):"[m
[31m-            self.get_logger().info([m
[32m+[m[32m            log_level([m
                 f"{log_prefix} Final Angles(deg): {np.round(final_target_angles_deg_np, 1)} -> Steps: {target_steps}"[m
             )[m
             [m
             send_ok = self.send_goal_positions(MOTORS_TO_COMMAND, target_steps)[m
[31m-            if send_ok: # Only update last_valid if send was successful[m
[32m+[m[32m            if send_ok:[m
                 if new_target_calculated_this_cycle:[m
                     self.last_valid_target_angles = final_target_angles_deg_np.copy()[m
[31m-                # Always update last_sent_target_steps if send was OK[m
                 self.last_sent_target_steps = target_steps.copy()[m
[31m-            else: # Send failed[m
[32m+[m[32m            else:[m
                  self.get_logger().warn("Failed to send target positions. Last valid target NOT updated.")[m
         except Exception as e_send_stage:[m
             self.get_logger().error(f"Exception during revert_calibration or write stage: {e_send_stage}")[m
[31m-            traceback.print_exc()[m
[31m-[m
[31m-        # loop_duration_ms = (self.get_clock().now() - start_time_loop).nanoseconds / 1e6[m
[31m-        # self.get_logger().debug(f"Control loop duration: {loop_duration_ms:.2f} ms")[m
[32m+[m[32m            # traceback.print_exc() # Uncomment for deep debugging[m
 [m
     def destroy_node(self):[m
         self.get_logger().info(f"Shutting down {NODE_NAME} node...")[m
[31m-        # Disable torque on all motors before closing port[m
         if self.port_handler is not None and self.packet_handler is not None and scs is not None:[m
              addr_torque = SCS_CONTROL_TABLE["Torque_Enable"][0][m
              self.get_logger().info(f"Attempting to disable torque for all arm motors...")[m
[31m-             for name, motor_info in LEADER_ARM_MOTORS.items(): # Iterate through all defined motors[m
[32m+[m[32m             for name, motor_info in LEADER_ARM_MOTORS.items():[m
                   motor_id = motor_info[0][m
                   try:[m
[31m-                      # Try twice to disable torque, as sometimes the first attempt might fail[m
                       for attempt in range(2): [m
                            scs_comm_result, scs_error = self.packet_handler.write1ByteTxRx(self.port_handler, motor_id, addr_torque, 0)[m
                            if scs_comm_result == scs.COMM_SUCCESS and scs_error == 0: break[m
[31m-                           time.sleep(0.01) # Small delay before retry[m
[32m+[m[32m                           time.sleep(0.01)[m
                       if not(scs_comm_result == scs.COMM_SUCCESS and scs_error == 0):[m
[31m-                           self.get_logger().warn(f"Could not disable torque for {name}({motor_id}) after retries. Res:{scs_comm_result}, Err:{scs_error}")[m
[32m+[m[32m                           self.get_logger().warn(f"Could not disable torque for {name}(ID:{motor_id}). Res:{scs_comm_result}, Err:{scs_error}")[m
                   except Exception as e_torque_disable:[m
[31m-                       self.get_logger().warn(f"Exception disabling torque for {name}({motor_id}): {e_torque_disable}")[m
[31m-                  time.sleep(0.02) # Stagger torque disable commands[m
[32m+[m[32m                       self.get_logger().warn(f"Exception disabling torque for {name}(ID:{motor_id}): {e_torque_disable}")[m
[32m+[m[32m                  time.sleep(0.02)[m
         [m
[31m-        self.cleanup_resources() # Close port and other resources[m
[32m+[m[32m        self.cleanup_resources()[m
         super().destroy_node()[m
         self.get_logger().info(f"{NODE_NAME} node shut down complete.")[m
 [m
 def main(args=None):[m
     rclpy.init(args=args)[m
     node = None[m
[31m-    logger = rclpy.logging.get_logger(f'{NODE_NAME}_main') # Use a specific logger for main[m
[32m+[m[32m    logger = rclpy.logging.get_logger(f'{NODE_NAME}_main')[m
     try:[m
         node = RealRobotInterfaceNode()[m
[31m-        # A more robust check to ensure node initialization was fully successful[m
         if not (node.port_handler and node.packet_handler and node.calibration_data and \[m
                 node.group_writer and node.group_reader and node.control_signal_subscription and \[m
[31m-                node.reader_motors_ok): # Add other critical components if any[m
[32m+[m[32m                node.joint_state_publisher and node.reader_motors_ok):[m
              logger.fatal("Node object created, but critical components are missing/uninitialized.")[m
              raise RuntimeError("Node initialization incomplete.")[m
         [m
[36m@@ -754,20 +768,20 @@[m [mdef main(args=None):[m
         rclpy.spin(node)[m
     except KeyboardInterrupt:[m
          logger.info('Ctrl+C detected, initiating shutdown.')[m
[31m-    except RuntimeError as e_runtime: # Catch specific RuntimeError from init[m
[31m-         logger.fatal(f"Caught RuntimeError during node setup: {e_runtime}")[m
[31m-         # traceback.print_exc() # Already printed in __init__ if it originated there[m
[31m-    except Exception as e_unhandled: # Catch any other unexpected exceptions[m
[32m+[m[32m    except RuntimeError as e_runtime:[m
[32m+[m[32m         logger.fatal(f"Caught RuntimeError during node setup or spin: {e_runtime}")[m
[32m+[m[32m         # traceback.print_exc() # Already printed if it originated in __init__[m
[32m+[m[32m    except Exception as e_unhandled:[m
         logger.fatal(f'Unhandled exception in main execution: {e_unhandled}')[m
         traceback.print_exc()[m
     finally:[m
         if node is not None:[m
             logger.info("Executing final node cleanup from main...")[m
[31m-            node.destroy_node() # This will call the class's destroy_node[m
[32m+[m[32m            node.destroy_node()[m
         else:[m
             logger.warn("Node object was None or not fully created, skipping destroy_node call from main.")[m
         [m
[31m-        if rclpy.ok(): # Check if RCLPY context is still valid[m
[32m+[m[32m        if rclpy.ok():[m
             rclpy.shutdown()[m
             logger.info("RCLPY shutdown complete.")[m
         print(f"{NODE_NAME} main process finished.")[m
[1mdiff --git a/src/so100_description/launch/display.launch.py b/src/so100_description/launch/display.launch.py[m
[1mindex 0d5d07f..1fecc47 100644[m
[1m--- a/src/so100_description/launch/display.launch.py[m
[1m+++ b/src/so100_description/launch/display.launch.py[m
[36m@@ -94,7 +94,7 @@[m [mdef generate_launch_description():[m
 [m
     use_jsp_gui_arg = DeclareLaunchArgument([m
         'use_jsp_gui',[m
[31m-        default_value='true',[m
[32m+[m[32m        default_value='false',[m
         description='Flag to enable joint_state_publisher_gui')[m
 [m
     rviz_config_file_arg = DeclareLaunchArgument([m
[36m@@ -118,4 +118,4 @@[m [mdef generate_launch_description():[m
 [m
     ld.add_action(OpaqueFunction(function=launch_setup))[m
 [m
[31m-    return ld[m
\ No newline at end of file[m
[32m+[m[32m    return ld[m
